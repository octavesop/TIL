# 1. 운영 체제의 개념과 발전 목적

## 1. 운영 체제의 개념
컴퓨터 시스템은 사용자, 소프트웨어, 하드웨어로 구성된다. 

운영 체제는 사용자가 접근할 수 있는 유일한 수단이며, 사용자가 응용 프로그램을 실행할 수 있는 기반 환경을 제공하고, 하드웨어를 효율적으로 사용할 수 있도록 돕는 소프트웨어이다.

![컴퓨터 시스템의 구성 요소와 운영 체제](./static/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%84%B1%20%EC%9A%94%EC%86%8C.jpg)

- **시스템 소프트웨어**: 컴퓨터 자원을 관리하고 응용 프로그램의 실행을 지원하여 컴퓨터를 제어하는 프로그램. 운영 체제를 비롯해 장치 드라이버 등으로 구성.

- **유틸리티**: 응용 프로그램보다 작지만 컴퓨터의 여러 처리 과정을 보조하고 시스템 유지 및 성능 개선에 기여하는 프로그램. 운영체제 보조 역할을 담당.

- **응용 프로그램**: 특정 작업을 수행하려는 목적 혹은 문제 해결을 위해 사용자가 만든 프로그램. 웹 브라우저, 워드 프로세서, 게임, 이미지 편집 프로그램, 은행 시스템 등이 해당.

<br>
<br>

## 2. 컴퓨터 관리 측면에서 운영 체제의 역할
### 조정자
컴퓨터 시스템은 하드웨어, 소프트웨어 둘 사이를 오가는 데이터로 구성된다. 운영 체제는 운영 요소들을 적절히 사용할 수 있도록 제어하며 사용자, 응용 프로그램 간에 통신할 수 있게 한다. 다른 프로그램이 수행하는 특정 작업이 아닌, **작업 환경을 제공하는 조정자 역할이다**.

워드 프로세서를 예로 들었을 때, 그 역할을 직접 하는 것이 아닌 기능을 위한 환경을 제공한다.
<br>

### 자원 할당자, 관리자
각 응용 프로그램에 필요한 자원을 할당하는 **자원 할당자**이며, 컴퓨터 시스템을 공정하고 효율적으로 운영하기 위해 그 방법을 결정하는 **관리자** 역할 또한 담당한다.

<br>

### 응용 프로그램과 입출력 장치 제어자
다양한 입출력 장치와 응용 프로그램을 제어하는 역할을 한다. **하드웨어 사용 조정**과 **응용 프로그램 실행을 제어**해 컴퓨터 시스템의 부적절한 사용과 오류 발생 방지를 담당한다. 특히 **입출력 장치의 동작과 통제**에 있어 핵심 역할을 맡는다.

<br>
<br>

## 3. 운영체제의 발전 목적
### 편리성
사용자가 프로그램을 효율적으로 실행할 수 있는 환경을 제공한다.

사용자가 편리하게 프로그램을 개발할 수 있는 환경과, 사용자와 컴퓨터 시스템이 정보 및 명령을 상호 교환할 수 있는 인터페이스를 제공한다.


### 효율성
각 프로그램을 유기적으로 결합해 시스템의 성능을 향상시켜야 한다.

시스템의 성능은 다음 기준으로 평가한다.
- **처리량**: 시스템의 생산성을 나타내는 지표. 단위 시간 당 처리하는 작업량.
- **지연, 응답시간**: 사용자가 시스템에 작업을 의뢰한 후 걸린 시간.
- **신뢰도**: 하드웨어(펌웨어), 소프트웨어가 실패 없이 주어진 기능을 수행하는 능력.
- **사용 가능도(가동률)**: 사용자가 일정 기간동안 컴퓨터를 실제로 사용한 시간. 고장과 오류가 발생해도 그 영향을 최소화해 시스템 전체를 중단하지 않고 운영하는 능력.

### 제어 서비스 향상
운영 체제는 서비스를 방해하지 않고 새로운 기능을 도입하고 테스트할 수 있도록 발전해야 함.

입출력 장치 동작 관리 및 제어, 시스템 오류 예방 등 컴퓨터 자원을 여러 사용자에게 효율적으로 할당하고 관리할 수 있도록 제어 서비스를 발전해 나가야 함.

<br>
<br>
<br>

# 2. 운영 체제의 기능
![운영 체제의 기능](/OS//static//%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98%20%EA%B8%B0%EB%8A%A5.jpg)

- **자원 관리**: 컴퓨터 시스템의 메모리, 프로세스, 장치, 파일 등의 관리.
- **시스템 관리**: 시스템 보호, 네트워킹, 명령 해석기 등의 기능 제공.

<br>

## 자원 관리

### 메모리 관리 - *메인 메모리 관리*
- **메인 메모리**: 프로세서가 직접 주소로 저장할 수 있는 유일한 메모리. 

운영체제는 메인 메모리 공간을 충분히 확보하고, 효율적으로 실행할 수 있도록 메모리를 적절히 사용해야 한다.

다음 세부 기능을 수행해 메인 메모리를 관리한다.
- 메모리의 어느 부분을 사용하고, 누가 사용하는지 점검한다.
- 메모리에 저장할 프로세스를 결정한다.
- 메모리를 할당하고 회수하는 방법을 결정한다.

<br>

### 메모리 관리 - *보조기억장치 관리*
- 빈 여유 공간을 관리한다.
- 새로운 파일을 작성할 때 저장 장소를 할당한다.
- 메모리 접근 요청을 스케줄링한다.
- 파일을 생성하고 삭제한다.

<br>

### 프로세스 관리
- 프로세스와 스레드를 스케줄링한다.
- 사용자 프로세스와 시스템 프로세스를 생성하고 제거한다.
- 프로세스를 중지하고 재수행한다.
- 프로세스 동기화 방법을 제공한다.
- 프로세스 통신 방법을 제공한다.
- 교착 상태`deadlock`를 방지하는 방법을 제공한다.

<br>

### 주변 장치(입출력 장치) 관리
운영 체제는 특수 프로그램인 장치 드라이브를 사용해 입출력 장치와 상호작용해 입출력 장치와 상호작용한다.

드라이버는 특정 하드웨어 장치와 통신할 수 있는 인터페이스를 제공하므로 특정 하드웨어에 종속된 프로그램이다.
- 임시 저장`buffer-caching` 시스템 기능을 제공한다.
- 일반 장치용 드라이버 인터페이스를 제공한다.
- 특정 장치 드라이버를 제공한다.

<br>

### 파일(데이터) 관리
입출력 파일의 위치, 저장과 검색 관리를 의미한다. 

운영 체제는 파일을 쉽게 사용하기 위해 디렉토리로 구성되며, 다수의 사용자가 접근 시 이 접근을 제어한다.

- 파일을 생성하고 삭제한다.
- 디렉터리를 생성하고 삭제한다.
- 보조기억장치에 있는 파일을 랩핑한다.
- 안전한 저장장치(비휘발성)에 파일을 저장한다.

<br>
<br>

## 시스템 관리

### 시스템 보호(사용자 권한 부여)
컴퓨터 자원에서 프로그램, 프로세스, 사용자 접근을 제어하는 방법.

파일 사용 권한 부여, 데이터 암호화 등 서비스를 제공해 데이터와 시스템을 보안.

<br>

### 네트워킹(통신)
프로세서의 연결 방식 및 통신의 경로 설정, 접속 정책, 충돌, 보안 등의 문제를 관리.

<br>

### 명령 해석기(Command Interpreter)
- **명령 해석기**: 사용자나 프로그램에서 대화형으로 입력한 명령어를 분석하고 실행하는 사용자와 운영 체제 간의 인터페이스. 사용자가 입력한 명령을 운영 체제에 전달하는 역할을 담당한다(하지만 운영체제는 아니다!).

명령 해석기는 일반적으로 커널에서 분리하는데, 비정상 프로세스가 커널의 특정 부분에 접근할 수 있기 때문이다.

<br>
<br>

# 3. 운영 체제의 발전 과정과 유형
## 1. 운영 체제의 발전 과정
### 1940 :: 운영 체제 없음(작업별 순차 처리)
당시는 사용자가 기계어로 직접 프로그램을 작성해 실행하는 **작업별 순차 처리 시스템**을 사용.

**운영 체제 개념은 존재하지 않음**.

컴퓨터가 모든 작업을 프로그램에 담고, 모든 것이 명령어로 표현되었다.

### 1950 :: 일괄 처리 방식
작업을 올리는 시간과 해제하는 시간을 줄이는 데 중점을 두었다. 데이터를 즉시 처리하지 않고 일정 기간 혹은 일정량이 될 때까지 모아두었다가 한번에 처리했다. 이때, *일괄 처리*, *버퍼링*, *스풀링* 등 방법을 도입했다.

- **일괄 처리**: 비슷한 작업들을 그룹으로 묶어 함께 일괄 처리함.

- **버퍼링**: 프로세서와 입출력 장치 속도차로 인해 입출력 장치별로 버퍼를 두어 프로세서에서 연산을 할 때 다른 작업을 입출력함. 그로 인해 시스템 성능을 향상시킬 수 있음.

- **스풀링**: 속도가 빠른 디스크를 버퍼처럼 사용해 입출력 장치에서 미리 읽는 것. 오프라인 장치를 사용한다는 점에서 버퍼링과 다름. 

### 1960 :: 다중 / 시분할 / 다중 처리 / 실시간 시스템 프로그래밍
장치 독립성(*프로그램을 다른 입출력 장치와 함께 실행할 수 있다는 개념*)을 이용한 편리한 하드웨어 관리, 다중 프로그래밍, 시분할, 다중 처리, 실시간 등을 이용한 시스템 처리 능력 향상이 이 시기 운영체제의 특징.

- **다중 프로그래밍 시스템**: 여러 프로그램을 메모리에 나눠서 적재 후 프로세서를 번갈아 할당해 프로세서의 사용을 극대화하면서 여러 프로그램을 동시에 실행.

- **시분할 시스템**: 다중 프로그래밍 시스템에 프로세서 스케줄링 개념을 추가.

- **다중 처리 시스템**: 하나의 시스템에서 프로세서를 여러 개 사용해 처리 능력을 높인 것.

- **실시간 시스템**: 즉시 응답하는 특성을 가짐.

<br>

### 1970 초반 :: 다중 모드 / 번용 시스템
모든 사용자에게 모든 기능을 제공하기 위해 범용 시스템으로 설계됨.

일괄 처리, 시분할 처리, 실시간 처리, 다중 처리를 모두 제공하는 `다중 모드 시스템` 또한 등장.

≫ 모든 사용자에게 동일하게 과도한 기능을 제공해 높은 러닝 커브 발생. 가격과 완성 시간도 오래 걸림.

<br>

### 1970~1990 :: 분산 처리 시스템, 병렬 계산 / 분산 계산
컴퓨터 네트워크를 이용해 멀리 떨어진 컴퓨터 사용 가능. 정보 보호가 관심사가 됨.

마이크로프로세서 등장으로 개인용 컴퓨터(PC)를 사용할 수 있어짐.

**1970년대** 명령어 중심 시스템 사용에서 **1980년대** 메뉴 지향적 시스템으로 발전. 이후 **1990년대** GUI 시스템으로 발전.

분산 처리 시스템(데이터가 발생하는 곳으로 컴퓨터의 능력을 가져옴) 확립.

<br>

### 2000 이후 :: 모바일, 임베디드, 가상화, 클라우드 컴퓨팅
* 모바일 기기와 모바일 운영체제(Android, iOS, 블랙베리 등)의 등장.

* 사물인터넷(IoT) 기술의 등장.

* 가상화(Virtualization) 기술 등장: 서버, 데스크탑, 스토리지, 네트워크 등에서 활용됨.

* 클라우드 컴퓨팅 기술 발전
    * **IaaS**: 데이터 센터의 인프라 및 자원을 가상화하여 인터넷으로 제공하는 방식. AWS의 EC2, S3 등. 
    * **PaaS**: 응용 프로그램의 구축, 테스트, 설치를 지원하는 통합 환경을 웹으로 제공하는 방식. 네이버의 OpenApi 등.
    * **SaaS**: 특정 소프트웨어를 인터넷으로 제공. 

<br>
<br>

## 4. 운영 체제의 유형
### 다중 프로그래밍 시스템
프로세서가 유휴 상태일 때 실행 중인 둘 이상의 작업이 프로세서를 전환(인터리빙)해 사용할 수 있도록 동작.

즉, 여러 프로그램을 메모리에 적재한 후 하나의 프로그램이 프로세서를 사용하다가 입출력 동작 등을 통해 프로세서를 사용하지 않는 유휴 시간 동안 타 프로그램이 프로세서를 사용하도록 하는 시스템.

<br>

### 시분할 시스템(TSS, Time Sharing System)
다중 프로그래밍을 논리적으로 확장한 개념. 프로세서가 다중 작업을 교대로 수행.

여러 작업(프로세스)을 메모리에 저장하므로 짧은 시간에 작업을 교체할 수 있도록 메모리를 적절하게 관리해야 함.

한 작업이 다른 작업의 데이터를 변경하는 등 작업 보호가 필요.

ex) 특정 권한이 있는 사용자만 접근할 수 있도록 파일 시스템을 보호, 공유 자원의 액세스 순서 조정 기능 제공.



<br>

### 다중 처리 시스템(MultiProcessing System)
단일 컴퓨터 시스템에서 둘 이상의 프로세서를 사용해 동시에 둘 이상의 프로세스를 지원하는 시스템.

여러 프로세서와 시스템 버스, 클록, 메모리 및 주변장치 등을 공유.

하나의 프로세서가 고장나도 다른 프로세서를 통해 작업을 계속할 수 있음.

<br>

### 실시간 처리 시스템(Real Time Processing System)
더 높은 적시 응답을 요하거나 엄격한 시간 요구가 있을 때 사용, 전용 응용 프로그램의 제어 장치로도 사용됨.

- **경성 실시간 처리 시스템**: 시간 제약 조건을 지키지 못했을 때 시스템에 치명적인 영향을 주는 시스템. `ex)` 무기 제어, 발전소 제어 등

- **연성 실시간 처리 시스템**: 시간 제약 조건이 있으나 이를 어겨도 전체 시스템에 치명적인 영향을 미치지 않는 시스템. `ex)` 동영상

<br>

### 분산 처리 시스템(Distributed Processing System)
시스템마다 독립적인 운영체제, 메모리로 운영하며, 필요할 때 통신하는 시스템. 

중앙집중식 시스템처럼 보이는데, 다수의 독립된 프로세서에서 실행됨.

데이터를 여러 위치에 처리, 저장하며 여러 사용자가 공유함.

하나의 프로그램을 여러 프로세서에서 동시에 실행할 수도 있음.


<br>
<br>

# 5. 운영 체제의 서비스
## 1. 부팅 서비스
- **부팅(부트스트래핑)**: 운영 체제를 메인 메모리에 적재하는 과정.

초기화 목적은 시스템 장치 초기화, 시간 설정, 명령 해석기 적재 및 준비.

<br>

## 2. 사용자 서비스
### 사용자 인터페이스 제공 
- **CLI(Command Line interface)**: 사용자가 키보드로 명령어를 입력해 시스템에서 응답을 받는 텍스트 전용 인터페이스.
- **메뉴 인터페이스**: 메뉴 등을 사용해 시스템과 상호 작용.
- **GUI(Graphic User Interface)**: 윈도우 환경에서 사용자에게 정보와 작업을 표현하는 텍스트, 레이블, 텍스트 탐색과 함게 위젯 그래픽 요소를 사용해 상호작용하는 보편적인 유형.


### 프로그램 실행
프로그램 실행 시 메모리에 적재하고 프로세서 시간을 할당해야 함.

프로그램 실행을 위해 메모리 할당, 해제, 프로세서 스케줄링과 같은 중요 작업 처리.


### 입출력 동작 수행
수행중인 프로그램의 입력을 처리 후 출력을 생성.

운영 체제는 입출력 동작을 직접 수행할 수 없는 사용자 프로그램의 입출력 동작 방법을 제공.


### 파일 시스템 조작
디스크에 파일이 저장될 때 특정 블록에 할당해 저장. 파일 삭제 시 파일 이름이 제거되면서 할당한 블록의 데이터를 제거. 파일 시스템 조작 서비스를 제공해 사용자가 파일 관련 작업을 편리하게 할 수 있게 함.


### 통신(네트워크)
1. 동일한 컴퓨터에서 수행하는 프로세스 간의 정보 교환.
2. 네트워크로 연결된 컴퓨터 시스템에서 수행하는 프로세스 간의 정보 교환.

다중 환경에서 공유 메모리를 이용하거나 메시지 전달로 다양한 유형의 프로세스와 통신을 지원하는 역할 담당.


### 오류 탐지
가능한 모든 하드웨어와 소프트웨어 수준에서 오류 탐지 및 시스템 모니터링을 통한 하드웨어 문제 예방.

입출력 장치와 관련된 오류, 메모리 오버플로우, 하드디스크 불량 섹터 검출 및 부적절한 메모리 접근과 데이터 손상 관리.

그 외에도 다음과 같은 오류 유형을 감지한 후 유형별로 적절히 조치.

- **프로세서, 메모리 하드웨어 관련 오류**: 기억장치 메모리 오류, 정전 등
- **입출력 장치 오류**: 테이프 패리티 오류, 카드 판독기 카드 체증(Card Jam), 프린터 종이 부족 등
- **사용자 프로그램 오류**: 연산 오버플로우, 부적절한 기억장치 장소 접근, 프로세서 시간 과소비 등

<br>

## 3. 시스템 서비스
사용자가 아닌 시스템 자체의 효율적인 동작을 보장하는 기능.

### 자원 할당
다수의 사용자 및 작업 동시 실행 시 자원을 각각 할당하도록 관리.

### 계정
각 사용자가 사용하는 컴퓨터 자원의 정보를 저장하고 추적. 

### 보호 및 보안
다중 사용자 컴퓨터 시스템에 저장된 정보 소유자의 사용 제한 가능.

ex) 사용자가 다수인 컴퓨터 시스템에서 여러 프로세스의 동시 실행 시 보안과 방어 등 사용.

<br>

## 4. 시스템 호출
프로그램과 운영 체제 간의 인터페이스 ≒ `API`(Application Programming Interfaces)

사용자 프로그램은 시스템 호출을 통해 운영 체제의 기능을 통해 제공받음.

시스템 호출에는 핵심 커널 서비스 및 통신, 새 프로세스 생성과 실행, 하드웨어 관련 서비스가 있음.

### 호출 방법
1. **프로그램 명령어나 서브루틴 호출 형태로 호출**: 일반적으로 어셈블리어로 제공하지만 고급 언어로 작성한 프로그램에서도 사용 가능.
2. **시스템에서 명령 해석기를 사용해 대화 형태로 호출**

![시스템 호출 예](../OS/static/%EC%8B%9C%EC%8A%A4%ED%85%9C%20%ED%98%B8%EC%B6%9C%20%EC%98%88%EC%8B%9C.jpg)

<br>
<br>

# 6. 운영 체제의 구조
## 1. 단일 구조 운영 체제(Monolithic)
초기에 생겨난 가장 보편적인 형태. 모든 기능을 커널과 동일한 메모리 공간에 적재해 시스템 호출만으로 사용할 수 있음.

- `장점`: 대부분의 기능을 커널에 그룹화해 구현, 시스템 자원의 효율적인 관리가 가능.
- `단점`: 커널 크기가 상대적으로 커 버그 원인과 오류를 구분하기 어려움. 유지보수가 어려움. 동일 메모리에서 실행하므로 한 부분의 문제가 전체 시스템에 큰 영향을 줄 수 있음. 악성 코드 피해에 취약.

ex) 초기 유닉스, DOS 등

![단일 커널 구조](/OS/static//%EB%8B%A8%EC%9D%BC%20%EC%BB%A4%EB%84%90%20%EA%B5%AC%EC%A1%B0.jpg)

<br>

## 2. 계층 구조 운영 체제
비슷한 기능을 수행하는 요소를 그룹화해 계층적으로 구성한다. 다수의 계층은 자신의 하위 계층 서비스와 기능만을 이용하므로 시스템 검증과 오류 수정이 수월하다.

사용자 프로세스의 요청을 수행할 때 여러 계층을 거쳐야 하므로 한 계층에서 다음 계층으로 데이터를 전달할 때마다 추가적인 시스템 호출이 발생한다.

- `장점`: 모듈화가 잘 되어 있다.
- `단점`: 계층 정의가 어렵다. 스와핑 기능이 필요하다. 모든 계층이 시스템 제한 없이 접근할 수 있어 악성 코드나 오류에 민감하다.

![계층 구조](/OS/static//%EA%B3%84%EC%B8%B5%20%EA%B5%AC%EC%A1%B0.jpg)

<br>

## 3. 마이크로 커널 구조 운영체제
커널의 기능을 최소한으로 구성해 크기를 대폭 줄이고 기타 기능은 사용자 공간으로 옮겨 사용자 영역에서 수행하는 서버 구현 방법.

하드웨어 초기화, 메모리 관리, 프로세스 및 스레드 관리와 프로세스 간 통신, 프로세스 간 협력을 하는 동기화 기능 등 기본 기능만 실행하고 네트워크 시스템, 파일 시스템 상호작용과 같은 대부분 운영 체제 구성 요소는 커널 외부, 즉 사용자 영역의 서버로 옮겨 구현.

- `장점`: 서버에서 명령을 잘못 수행해도 다른 서버와 커널에 치명적인 영향을 주지 않음. 많은 기능을 사용자 영역의 서버로 구현할 수 있어 서버 개발이 용이함. 운영 체제 기능을 쉽게 변경할 수 있음. 확장성, 이식성, 규모 확장성이 높음.
- `단점`: 모듈 간 통신이 빈번하게 일어나 성능이 떨어질 수 있음. 응용 프로그램과 서버 간 문맥 교환에 의해 속도가 느림. 

![마이크로 커널 구조](/OS/static//%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%20%EC%BB%A4%EB%84%90%20%EA%B5%AC%EC%A1%B0.jpg)