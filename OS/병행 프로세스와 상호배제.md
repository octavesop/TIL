# 1. 병행 프로세스
프로세서 하나는 하나의 프로세스만 실행할 수 있는데, 이때 운영체제가 프로세서를 빠르게 전환해 시간을 나눠 마치 프로세스 여러 개를 동시에 실행하는 것처럼 보이게 하는 것.

독립 프로세스와 협력 프로세스로 나뉜다.

<br>

## 독립 프로세스
- 단일 처리 시스템에서 수행하는 병행 프로세스.
- 다른 프로세스에 영향을 주고받지 않으면서 독립적으로 실행.
- 의존성이 없기 때문에 
- *단일 프로그래밍*, *다중 프로그래밍*, *다중 처리* 등에서 활용.

<br>

## 협력 프로세스
- 다른 프로세스에 영향을 주고 받으며 특정 기능을 수행하는 비동기적 프로세스.
- 제한된 컴퓨터 자원의 효율성을 증대, 계산 속도 증대, 모듈적 구성 강화, 여러 작업을 동시에 수행하는 편의성을 제공.
- 입출력 장치, 메모리, 프로세서, 클록과 같은 자원을 서로 사용하려 할 시 충돌이 발생.
- 일반적으로 서로를 인식하고 통신할 수 있는 기본 함수를 가져 병행해 함께 동작할 수 있음.

<br>

## 병행 프로세스의 해결 과제
1. 공유 자원은 상호 배타적으로 사용해야 한다.
2. 병행 프로세스 간에는 협력 혹은 동기화가 이뤄져야 한다.
3. 두 프로세스 사이에서는 데이터 교환을 위한 통신이 가능해야 한다.
4. 프로세스는 다른 프로세스의 실행 속도와 관련없이 항상 일정한 실행 결과를 보장하기 위한 **결정성(Determinacy)**을 확보해야 한다.
5. 교착 상태를 해결하고 병행 프로세스들의 병렬 처리 능력을 극대화해야 한다.
6. 실행 검증 문제를 해결해야 한다.
7. 어떤 프로세스가 작업을 실행 중일 때 나머지 프로세스는 그것과 관련된 작업을 수행할 수 없도록 보장해야 한다.

<br>

## 상호배제 방법

### 선행 그래프
- 프로세스 집합, 선행 제약(Precedence constraint) 두 가지 요소로 구성.
- **선행 제약**: 프로세스를 순서대로 다른 상태로 옮기는 것. 선행 제약이 없을 경우, 둘은 독립적이므로 병행 실행이 가능.
- 선행 그래프는 선행 제약을 논리적으로 표현한 것.
- 순환적일 경우 제약 동시 만족이 불가능한 경우가 생겨 모순이 발생할 수 있음.

<br>

### fork와 join 구조
- 콘웨이(Conway), 데니스(Dennis), 혼(Van Horn)이 소개한 개념.
- `fork` 수행 시 새로운 연산 프로세스를 시작하고, 같은 급의 연산 프로세스와 병행해 수행.
- `join` 수행 시 병행 연산 2개를 하나로 결합하는 방법을 제공.
- 두 연산은 서로 속도가 다르므로 둘 중 하나를 먼저 join을 수행하고, 그 후 다른 연산을 수행.
- join 명령어는 단위적으로 수행되어야 함.

<br>

### 병행 문장
- 하나의 프로세스가 여러 병렬 프로세스로 퍼졌다가 다시 하나로 뭉쳐지는 것을 나타내는 고급 언어 구조.
- 다익스트라의 *parbegin/parend*가 대표적인 사례.
- 블록 구조의 고급 언어에 쉽게 추가할 수 있고, 다른 구조적 제어 문장의 장점을 많이 보여줌.

<br>

# 2. 상호배제와 동기화

### 상호배제(Mutual Exclusion)
: 병행 프로세스에서 프로세스 하나가 공유 자원을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법.

프로세스가 **수정**할 수 있는 공유 데이터에 접근할 때만 적용하고, 단순 읽기 등을 할 때는 동시에 수행하도록 허용해야 함.

또한 다음 네 조건을 충족해야 함.
1. 두 프로세스는 동시에 공유 자원에 진입할 수 없음.
2. 프로세스의 속도나 프로세서 수에 영향을 받지 않음.
3. 공유 자원을 사용하는 프로세스만 다른 프로세스를 차단할 수 있음.
4. 프로세스가 공유 자원을 사용하려고 너무 오래 기다려서는 안됨.

---

- **임계 자원(Critical Resource)**: 두 프로세스가 동시에 사용할 수 없는 공유 자원.
- **임계 영역(Critical Section)**: 임계 자원에 접근하고 실행하는 프로그램 코드 부분.


## 2. 임계 영역
임계 영역은 다음 세 가지 조건을 만족해야 한다.
1. **상호 배제**: 어떤 프로세스가 임계 영역에서 작업 중이면 다른 프로세스는 임계 영역으로 들어갈 수 없다.
2. **진행**: 임계 영역에 프로세스가 없는 상태에서 여러 프로세스가 들어가려고 할 때는 어떤 프로세스가 
3. **한정 대기**: 다른 프로세스가 임계 영역을 무한정 기다리는 상황을 방지하기 위해서는 임계 영역에 한번 들어갔던 프로세스는 다음에 임계 영역에 다시 들어갈 때 제한을 둔다.

## 3. 생산자, 소비자 문제와 상호배제 해결을 위한 초기 시도
### 생산자, 소비자 문제
: 운영 체제에서 비동기적으로 수행하는 모델. 생산자 프로세스가 생산한 정보를 소비자 프로세스가 소비하는 형태.

생산자는 소비자에게 데이터를 전송할 때 데이터를 소비자가 받을 준비를 하면 데이터를 전송하고 소비자가 계속 처리하지 못하면 대기해야 하므로, 이때 불필요한 공회전을 방지하는 전송 방법이 필요한데, 이는 임시 기억 장소인 버퍼 도입을 통해 해결할 수 있다.

![공유 버퍼를 이용한 데이터 전송과 수신](./static/%EA%B3%B5%EC%9C%A0%20%EB%B2%84%ED%8D%BC%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A0%84%EC%86%A1%EA%B3%BC%20%EC%88%98%EC%8B%A0.jpg)

![공유 버퍼의 세 가지 상태](./static/%EA%B3%B5%EC%9C%A0%20%EB%B2%84%ED%8D%BC%EC%9D%98%20%EC%84%B8%20%EA%B0%80%EC%A7%80%20%EC%83%81%ED%83%9C.jpg)

### 무한 버퍼일 때
생산자와 소비자는 독립적으로 알고리즘을 수행해 버퍼를 활용할 수 있음.

### 유한 버퍼일 때
논리적 포인터 `in`과 `out` 2개의 버퍼를 순환 배열로 구현해 해결할 수 있음.

소비자는 in>out을 확인해 버퍼에서 데이터를 읽기 전 생산자가 앞서가고 있는지 확인할 수 있음.

![순환형 버퍼](./static/%EC%88%9C%ED%99%98%20%EB%B2%84%ED%8D%BC%EC%9D%98%20%EA%B5%AC%EC%A1%B0.jpg)

그러나 여러 프로세스가 동시에 공유 데이터에 접근할 때 접근 순서에 따라 실행 결과가 달라지는 상황에 놓일 수 있다. 이를 **경쟁 상태(Race Condition)**에 있다고 표현한다.

이렇게 될 경우 공유 데이터에 마지막으로 남는 데이터의 결과를 보장할 수 없으므로, 장치나 시스템이 둘 이상의 연산을 동시 실행할 때 마지막으로 남는 데이터의 결과를 보장할 수 없다.

어느 프로세스를 마지막으로 수행한 후 결과를 저장하는지에 따라 오류가 발생할 수 있다.

### 어떻게 해결해야 할까?
1. 적절한 순서가 필요하다. 일반적으로 읽기 명령을 먼저 수행한 후 그 다음에 쓰기 명령을 수행해야 한다. 이를 **접근 순서화** 라고 한다.
2. 조작 시에 하나의 프로세스만 접근할 수 있게 임계 영역으로 설정한다.


<br>
<br>

# 3. 상호배제 방법들

## 1. 데커의 알고리즘
1. 두 프로세스가 동시에 임계 영역에 진입하려고 시도하면 순서에 따라 오직 하나만 임계 영역에 들어가도록 허용.
2. 각 프로세스는 플래그를 설정할 수도, 다른 프로세스를 확인한 후 플래그를 재설정할 수도 있음.
3. 프로세스가 임계 영역에 진입하고 싶으면 플래그를 설정하고 차례를 기다리면서 순환 대기 상태가 된다.
4. 프로세스 2개가 동시에 임계 영역에 진입하도록 플래그를 설정하면 교착 상태에 빠지게 됨.

<br>

## 2. TestAndSet(TAS) 명령어
1. 메모리 영역의 값에 대해 검사와 수정을 원자적으로 수행할 수 있는 하드웨어 명령어.
2. 해당 주소의 값을 읽고 새 값으로 교체하면서 해당 메모리 위치의 이전 값을 돌려줌.

### 장점
- 사용자 수준에서 가능.
- 메인 메모리를 공유하는 다중 프로세서나 단일 프로세서에서 프로세스 수에 관계없이 적용할 수 있음.
- lock 변수 수에 상관없이 구현 가능.
- 구현이 단순하고 확인이 용이함.
- 다중 임계 영역을 지원.

### 단점
- 바쁜 대기 발생.
- 프로세서 시간 소모가 큼.
- 대기 프로세스는 비생산적이며 자원이 소모되는 대기 루프에 남음.
- **기아 상태** 발생 : 프로세스가 임계 영역을 떠날 때 프로세스 하나 이상을 대기하는 경우 가능.
- **교착 상태** 발생 : 플래그는 우선순위가 낮은 프로세스가 재설정할 수 있으나, 우선순위가 높은 프로세스가 선점. 따라서 우선순위가 낮은 프로세스는 lock을 가지고, 우선순위가 높은 프로세스가 이를 얻으려 시도할 때 높은 우선순위 프로세스는 무한정 바쁜 대기가 됨.

<br>

## 3. 세마포(Semaphore)
진입 조건을 반복 조사하지 않고 true일 때 프로세스 상태를 확인해 프로세서 사이클을 낭비하지 않도록 하는 것이 목적.

상호배제에 사용할 뿐 아니라 다양한 연산의 순서도 제공. 임계 영역 구현 및 스케줄링 제약 조건을 시행할 수 있음.

### 이진 세마포(Binary Semaphore)
세마포 S를 상호배제에 사용하고, 1 또는 0으로 초기화하고, P와 V의 연산을 교대로 실행.

### 계수 세마포(Counting Semaphore)
유한한 자원에 접근하는 것을 제어할 수 있음. 여러 번 획득하거나 해제할 수 있도록 count를 자원의 사용 허가 값으로 사용. 사용 가능한 자원 수로 초기화하므로, count를 초기의 세마포 수로 초기화함.

### 단점
- wait 및 signal 연산을 생략하면 상호배제 문제가 발생하고, wait 연산으로 인해 대기하는 프로세스들이 교착 상태에 빠질 수 있다는 취약점이 발생.
- wait와 signal 연산이 프로그램 전체에 퍼져있고, 이들 연산이 각 세마포에 주는 영향을 전체적으로 파악하기 쉽지 않아 잘못 사용하면 여러 오류가 쉽게 발생해 프로그램 작성이 어려움. 


<br>

## 4. 모니터
1. 공유 데이터, 임계 영역이 코딩된 프로시저, 초기화 코드로 구성된 모듈.
2. 사용자 사이에서 통신하려고 동기화하고, 자원에 배타적으로 접근할 수 있도록 프로세스가 사용하는 병행 프로그래밍 구조.
3. 초기화 코드는 모니터를 생성할 때만 사용.
4. 공유 데이터의 변수는 모니터 내부에 있는 프로시저로만 접근할 수 있음.
5. 어떤 프로세스가 모니터를 점유하고 있으면, 다른 프로세스는 모니터에 진입하지 못하도록 차단함.

<br>

## 5. etc
### 다익스트라(Dijkstra)
최초로 프로세스 n개의 상호배제 문제를 소프트웨어적으로 해결. 실행 시간이 가장 짧은 프로세스에 프로세서를 할당하는 세마포 방법으로, 가장 짧은 평균 대기시간을 제공.

### 크누스(Knuth)
이전 알고리즘 관계 분석 후 일치하는 패턴을 찾아 패턴의 반복을 줄여 프로세스에 프로세서를 할당하는 방법.

무한정 연기할 가능성을 배제하는 해결책을 제시했으나, 프로세스들이 아주 오래 기다려야 함.

### 램포트(Lamport)
사람들로 붐비는 빵집에서 번호표를 뽑아 빵을 사려고 기다리는 사람들에 비유해 만든 알고리즘. 준비 상태 큐에서 

### 핸슨(Brinch Hansen)
실행 시간이 긴 프로세스에 불리한 부분을 보완하는 것으로 대기시간에 실행 시간을 이용하는 모니터 방법. 분산 처리 프로세서 간의 병행성 제어를 많이 발표.