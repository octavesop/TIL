# 1. 병행 프로세스
프로세서 하나는 하나의 프로세스만 실행할 수 있는데, 이때 운영체제가 프로세서를 빠르게 전환해 시간을 나눠 마치 프로세스 여러 개를 동시에 실행하는 것처럼 보이게 하는 것.

독립 프로세스와 협력 프로세스로 나뉜다.

<br>

## 독립 프로세스
- 단일 처리 시스템에서 수행하는 병행 프로세스.
- 다른 프로세스에 영향을 주고받지 않으면서 독립적으로 실행.
- 의존성이 없기 때문에 
- *단일 프로그래밍*, *다중 프로그래밍*, *다중 처리* 등에서 활용.

<br>

## 협력 프로세스
- 다른 프로세스에 영향을 주고 받으며 특정 기능을 수행하는 비동기적 프로세스.
- 제한된 컴퓨터 자원의 효율성을 증대, 계산 속도 증대, 모듈적 구성 강화, 여러 작업을 동시에 수행하는 편의성을 제공.
- 입출력 장치, 메모리, 프로세서, 클록과 같은 자원을 서로 사용하려 할 시 충돌이 발생.
- 일반적으로 서로를 인식하고 통신할 수 있는 기본 함수를 가져 병행해 함께 동작할 수 있음.

<br>

## 병행 프로세스의 해결 과제
1. 공유 자원은 상호 배타적으로 사용해야 한다.
2. 병행 프로세스 간에는 협력 혹은 동기화가 이뤄져야 한다.
3. 두 프로세스 사이에서는 데이터 교환을 위한 통신이 가능해야 한다.
4. 프로세스는 다른 프로세스의 실행 속도와 관련없이 항상 일정한 실행 결과를 보장하기 위한 **결정성(Determinacy)**을 확보해야 한다.
5. 교착 상태를 해결하고 병행 프로세스들의 병렬 처리 능력을 극대화해야 한다.
6. 실행 검증 문제를 해결해야 한다.
7. 어떤 프로세스가 작업을 실행 중일 때 나머지 프로세스는 그것과 관련된 작업을 수행할 수 없도록 보장해야 한다.

<br>

## 상호배제 방법

### 선행 그래프
- 프로세스 집합, 선행 제약(Precedence constraint) 두 가지 요소로 구성.
- **선행 제약**: 프로세스를 순서대로 다른 상태로 옮기는 것. 선행 제약이 없을 경우, 둘은 독립적이므로 병행 실행이 가능.
- 선행 그래프는 선행 제약을 논리적으로 표현한 것.
- 순환적일 경우 제약 동시 만족이 불가능한 경우가 생겨 모순이 발생할 수 있음.

<br>

### fork와 join 구조
- 콘웨이(Conway), 데니스(Dennis), 혼(Van Horn)이 소개한 개념.
- `fork` 수행 시 새로운 연산 프로세스를 시작하고, 같은 급의 연산 프로세스와 병행해 수행.
- `join` 수행 시 병행 연산 2개를 하나로 결합하는 방법을 제공.
- 두 연산은 서로 속도가 다르므로 둘 중 하나를 먼저 join을 수행하고, 그 후 다른 연산을 수행.
- join 명령어는 단위적으로 수행되어야 함.

<br>

### 병행 문장
- 하나의 프로세스가 여러 병렬 프로세스로 퍼졌다가 다시 하나로 뭉쳐지는 것을 나타내는 고급 언어 구조.
- 다익스트라의 *parbegin/parend*가 대표적인 사례.
- 블록 구조의 고급 언어에 쉽게 추가할 수 있고, 다른 구조적 제어 문장의 장점을 많이 보여줌.

<br>

# 2. 상호배제와 동기화

### 상호배제(Mutual Exclusion)
: 병행 프로세스에서 프로세스 하나가 공유 자원을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법.

프로세스가 **수정**할 수 있는 공유 데이터에 접근할 때만 적용하고, 단순 읽기 등을 할 때는 동시에 수행하도록 허용해야 함.

또한 다음 네 조건을 충족해야 함.
1. 두 프로세스는 동시에 공유 자원에 진입할 수 없음.
2. 프로세스의 속도나 프로세서 수에 영향을 받지 않음.
3. 공유 자원을 사용하는 프로세스만 다른 프로세스를 차단할 수 있음.
4. 프로세스가 공유 자원을 사용하려고 너무 오래 기다려서는 안됨.

---

- **임계 자원(Critical Resource)**: 두 프로세스가 동시에 사용할 수 없는 공유 자원.
- **임계 영역(Critical Section)**: 임계 자원에 접근하고 실행하는 프로그램 코드 부분.


## 2. 임계 영역
임계 영역은 다음 세 가지 조건을 만족해야 한다.
1. **상호 배제**: 어떤 프로세스가 임계 영역에서 작업 중이면 다른 프로세스는 임계 영역으로 들어갈 수 없다.
2. **진행**: 임계 영역에 프로세스가 없는 상태에서 여러 프로세스가 들어가려고 할 때는 어떤 프로세스가 
3. **한정 대기**: 다른 프로세스가 임계 영역을 무한정 기다리는 상황을 방지하기 위해서는 임계 영역에 한번 들어갔던 프로세스는 다음에 임계 영역에 다시 들어갈 때 제한을 둔다.

## 3. 생산자, 소비자 문제와 상호배제 해결을 위한 초기 시도
### 생산자, 소비자 문제
: 운영 체제에서 비동기적으로 수행하는 모델. 생산자 프로세스가 생산한 정보를 소비자 프로세스가 소비하는 형태.

생산자는 소비자에게 데이터를 전송할 때 데이터를 소비자가 받을 준비를 하면 데이터를 전송하고 소비자가 계속 처리하지 못하면 대기해야 하므로, 이때 불필요한 공회전을 방지하는 전송 방법이 필요한데, 이는 임시 기억 장소인 버퍼 도입을 통해 해결할 수 있다.

![공유 버퍼를 이용한 데이터 전송과 수신](./static/%EA%B3%B5%EC%9C%A0%20%EB%B2%84%ED%8D%BC%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A0%84%EC%86%A1%EA%B3%BC%20%EC%88%98%EC%8B%A0.jpg)

![공유 버퍼의 세 가지 상태](./static/%EA%B3%B5%EC%9C%A0%20%EB%B2%84%ED%8D%BC%EC%9D%98%20%EC%84%B8%20%EA%B0%80%EC%A7%80%20%EC%83%81%ED%83%9C.jpg)

### 무한 버퍼일 때
생산자와 소비자는 독립적으로 알고리즘을 수행해 버퍼를 활용할 수 있음.

### 유한 버퍼일 때
논리적 포인터 `in`과 `out` 2개의 버퍼를 순환 배열로 구현해 해결할 수 있음.

소비자는 in>out을 확인해 버퍼에서 데이터를 읽기 전 생산자가 앞서가고 있는지 확인할 수 있음.

![순환형 버퍼](./static/%EC%88%9C%ED%99%98%20%EB%B2%84%ED%8D%BC%EC%9D%98%20%EA%B5%AC%EC%A1%B0.jpg)

그러나 여러 프로세스가 동시에 공유 데이터에 접근할 때 접근 순서에 따라 실행 결과가 달라지는 상황에 놓일 수 있다. 이를 **경쟁 상태(Race Condition)**에 있다고 표현한다.

이렇게 될 경우 공유 데이터에 마지막으로 남는 데이터의 결과를 보장할 수 없으므로, 장치나 시스템이 둘 이상의 연산을 동시 실행할 때 마지막으로 남는 데이터의 결과를 보장할 수 없다.

어느 프로세스를 마지막으로 수행한 후 결과를 저장하는지에 따라 오류가 발생할 수 있다.

### 어떻게 해결해야 할까?
1. 적절한 순서가 필요하다. 일반적으로 읽기 명령을 먼저 수행한 후 그 다음에 쓰기 명령을 수행해야 한다. 이를 **접근 순서화** 라고 한다.
2. 조작 시에 하나의 프로세스만 접근할 수 있게 임계 영역으로 설정한다.