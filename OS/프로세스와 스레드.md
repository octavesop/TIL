# 1. 프로세스의 개념과 상태 변화
## 프로세스(Process)
- 실행 중인 프로그램 <- `가장 일반적인 정의`
- 비동기적(Asynchronous) 행위
- 실행 중인 프로시저
- 실행 중인 프로시저의 제어 추적
- 운영 체제에 들어 있는 프로세스 제어 블록(PCB)
- 프로세서에 할당하여 실행할 수 있는 개체 디스패치(dispatch)가 가능한 대상


![프로세스의 구조](/OS//static//%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B5%AC%EC%A1%B0.jpg)

### 스택(Stack)
- 데이터를 일시적으로 저장하는 영역.
- **지역변수**에 사용. 변수가 범위 밖으로 이동할 때 공간을 해제.
- 함수를 호출할수록 커지고 반환할수록 줄어듦.

### 힙(Heap)
- 코드 영역과는 별도로 유지되는 **자유 영역**.
- 동적 메모리 할당과 프로그램 실행 중 시스템 호출 사용 및 해제 시 활용.
- 프로젝트 공유 라이브러리와 동적 적재 모듈이 서로 공유.

### 데이터(Data)
- 프로그램의 가상의 주소 공간.
- 전역변수, 정적 변수의 저장 및 할당에 사용.
- 실행 전 초기화되지만 실행 시간에 변경이 가능.
- 초기화하지 않은 데이터는 데이터 영역의 끝에 자리함.

### 코드(Code)
- 실행 명령을 포함하는 메모리 및 목적 파일에 있는 프로그램 영역.
- 프로그램을 시작할 대 프로세서가 디스크에서 읽어 실행되는 프로그램의 컴파일 본을 저장.

<br>
<br>

## 프로세스의 종류
1. 역할에 따른 종류

### 시스템(커널) 프로세스
- 모든 시스템 메모리 및 프로세스 명령에 액세스할 수 있는 프로세스.
- 프로세스 실행 순서 제어 및 다른 사용자 및 커널 영역을 침범하지 못하게 감시.
- 사용자 프로세스를 생성하는 역할을 담당.

### 사용자 프로세스
- 사용자 코드를 수행하는 프로세스.

---

2. 병행 수행 방법에 따른 종류

### 독립 프로세스
- 다른 프로세스에 영향을 주지 않거나 프로세스의 영향을 받지 않으면서 수행하는 병행 프로세스.

### 병행 프로세스
- 다른 프로세스에 영향을 주거나 다른 프로세스에서 영향을 받는 병행 프로세스.

<br>
<br>

## 프로세스의 상태 변화와 상태 정보
### 준비 -> 실행(`Dispatch`)
- 준비 큐 맨 앞에 있던 프로세스가 프로세서를 점유하는 과정.
- 실행 상태인 프로세스가 할당된 시간만큼만 프로세서를 사용하도록 해 특정 프로세스가 프로세서를 과독점하는 것을 방지.

### 실행 -> 준비(`TimeOut`)
- 인터럽트 클록을 통해 특정 프로세스가 할당된 시간 동안만 프로세서를 점유하게 함.
- 타임아웃 이후에도 프로세서를 반환하지 않을 시 클록이 인터럽트를 발생시켜 운영체제에 제어권 부여.


### 실행 -> 대기(보류)(`Block`)
- 할당된 시간 이전에 실행 상태의 프로세스에 입출력 연산 등이 필요할 때, 혹은 새 자원 요청 등의 문제로 프로세서를 스스로 양도한 상태.

### 대기(보류) -> 준비(`WakeUp`)
- 입출력 작업이 끝난 후의 상태.

<br>

## 프로세스 제어 블록
프로세스 제어 시 상태 정보와 관련한 내용은 **프로세스 제어 블록(PCB)**에 저장됨.

때문에 **작업 제어 블록(Task Control Block)**이라고도 함.

- 다음과 같은 정보가 저장되고 운영체제의 모든 모듈은 이 정보를 읽고 수정할 수 있음.

![프로세스 제어 블록](./static//%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EC%A0%9C%EC%96%B4%20%EB%B8%94%EB%A1%9D.jpg)

## 프로세스 문맥 교환
: 인터럽트 및 시스템 호출 등으로 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 살행 상태가 되도록 하는 것. 레지스터에 있던 내용은 나중에 사용하도록 저장한다.

예시는 다음과 같다.

![프로세스 문맥 교환 예시](./static//%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%AC%B8%EB%A7%A5%20%EA%B5%90%ED%99%98%20%EC%98%88%EC%8B%9C.jpg)

<br>
<br>

# 2. 프로세스의 관리


## 1. 프로세스의 구조
프로세스는 실행 중 프로세스 생성 시스템 호출을 통해 새 프로세스를 생성할 수 있다.

- **부모 프로세스**: 프로세스를 새로 실행하는 프로세스.
- **자식 프로세스**: 생성되는 프로세스. **서브 프로세스**라고도 함.

<br>

## 2. 프로세스의 생성
1. 운영체제, 응용 프로그램에서 요청을 받아 프로세스를 생성.
2. 운영체제가 해당 프로세스에서 프로세스 제어 블록(PCB)을 만들어 주소 공간 할당.
3. 프로세스 제어 블록 초기화(프로세스 상태, 프로그램 카운터 초기화 및 자원 요청, 프로세스 제어 정보 등 포함).
4. 링크를 걺(해당 큐에 삽입).

<br>

## 3. 프로세스의 종료
- **정상 종료**: 프로세스가 운영체제의 서비스를 호출할 때
- **시간 초과**: 프로세스가 명시된 전체 시간을 초과해 실행하거나 명시된 시간을 초과하면서 이벤트 발생을 기다릴 때
- **실패**: 파일 검색 실패, 입출력이 명시된 횟수를 초과해 실패할 때
- **etc**: 산술 오류, 보호 오류, 데이터 오류, 메모리 부족, 액세스 위반 등

<br>

## 4. 프로세스의 제거
- 프로세스 제거 시 사용 자원은 시스템에 반납하고 해당 프로세스의 PCB를 회수.
- 하지만 프로그램은 여전히 디스크에 저장.
- 자식 프로세스는 부모 프로세스를 제거하면 자동으로 제거됨.

<br>

## 5. 프로세스의 중단과 재시작
프로세스의 준비, 실행, 대기는 일반 연산보다 느려 대부분 유휴 상태인데, 이 문제를 해결하기 위해 프로세스 중단(일시정지) 상태를 도입하면 대기가 아닌 중단 상태가 되므로 이벤트가 발생 시 즉시 실행되게 바꿀 수 있다.

- **대기**: 자원을 할당받기 위해 기다리는 상태
- **중단**: 할당받은 자원을 기다리는 상태.

그 외에도 다음과 같은 상황에 사용한다.

- 시스템 장애 발생 시 기능 회복 재시작을 위하여
- 프로세스의 의심스러운 부분 확인 후 재시작 혹은 종료를 위하여
- 처리 작업 과다로 시스템에 부담이 갈 때 프로세스 조절을 위하여

<br>

## 프로세스의 우선순위 변경
- 프로세스 스케줄러가 PCB에 있는 우선순위를 이용해 준비 리스트의 프로세스 처리.
* 준비 리스트의 프로세스는 *프로세서 중심 프로세스*와 *입출력 중심 프로세스*로 구분.
    * **프로세서 중심 프로세스**: 속도가 느리면서 빠른 응답을 요구하는 단말기에 높은 우선순위 부여, 시간이 적게 할당됨. 
    * **입출력 중심 프로세스**: 속도가 빠르므로 낮은 우선순위를 부여. 시간이 많이 할당됨.

<br>

## 프로세스의 문맥 교환
현재 프로세스와 별도로 외부 이벤트 발생시 인터럽트가 발생. 이때, 인터럽트 처리 루틴으로 제어가 넘어간 후 유형에 따라 관련 루틴으로 분기.

- **입출력 인터럽트**: 입출력 동작 발생을 확인하고 이벤트를 기다리는 프로세스를 준비 상태로 바꾼 후 실행할 프로세스를 결정.
- **클록 인터럽트**: 현재 실행 중인 프로세스 할당 시간을 조사해 실행 중인 프로세스를 준비 상태로 변경한 후 다른 프로세스를 실행 상태로 변경.

인터럽트 발생 시 운영체제가 다른 프로세스를 실행 상태로 변경하고 제어를 넘겨 프로세스 문맥 교환이 발생. 그러나, 현재 프로세스를 재실행할 가능성이 있으므로 인터럽트가 프로그램 문맥 교환으로 발전하지는 않음.

- **문맥 교환(Context Switching)**: 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 저장해 프로세스를 교환하는 과정. 대개 *준비 -> 실행* 시 혹은 *실행 -> 대기* 상태일 때 발생. 오버헤드가 발생하며, 가능하면 불필요한 문맥 교환을 줄일 수 있어야함.